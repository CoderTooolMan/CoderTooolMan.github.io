I"ı<h2 id="968ç›‘æ§äºŒå‰æ ‘">968.ç›‘æ§äºŒå‰æ ‘</h2>

<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæˆ‘ä»¬åœ¨æ ‘çš„èŠ‚ç‚¹ä¸Šå®‰è£…æ‘„åƒå¤´ã€‚</p>

<p>èŠ‚ç‚¹ä¸Šçš„æ¯ä¸ªæ‘„å½±å¤´éƒ½å¯ä»¥ç›‘è§†å…¶çˆ¶å¯¹è±¡ã€è‡ªèº«åŠå…¶ç›´æ¥å­å¯¹è±¡ã€‚</p>

<p>è®¡ç®—ç›‘æ§æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æ‰€éœ€çš„æœ€å°æ‘„åƒå¤´æ•°é‡ã€‚</p>

<p>ç¤ºä¾‹ 1ï¼š<img src="\image\image-20220520225255926.png" alt="p1" /></p>

<p>è¾“å…¥ï¼š[0,0,null,0,0]</p>

<p>è¾“å‡ºï¼š1</p>

<p>è§£é‡Šï¼šå¦‚å›¾æ‰€ç¤ºï¼Œä¸€å°æ‘„åƒå¤´è¶³ä»¥ç›‘æ§æ‰€æœ‰èŠ‚ç‚¹ã€‚</p>

<p>ç¤ºä¾‹ 2ï¼š<img src="\image\image-20220520225311331.png" alt="p1" /></p>

<p>è¾“å…¥ï¼š[0,0,null,0,null,0,null,null,0]</p>

<p>è¾“å‡ºï¼š2</p>

<p>è§£é‡Šï¼šéœ€è¦è‡³å°‘ä¸¤ä¸ªæ‘„åƒå¤´æ¥ç›‘è§†æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚ ä¸Šå›¾æ˜¾ç¤ºäº†æ‘„åƒå¤´æ”¾ç½®çš„æœ‰æ•ˆä½ç½®ä¹‹ä¸€ã€‚</p>

<p>æç¤ºï¼š</p>

<p>ç»™å®šæ ‘çš„èŠ‚ç‚¹æ•°çš„èŒƒå›´æ˜¯ [1, 1000]ã€‚</p>

<p>æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ 0ã€‚</p>

<h3 id="æ€è·¯">æ€è·¯</h3>

<p>ååºéå†ï¼Œæ¯ä¸ªèŠ‚ç‚¹å‘ä¸Šä¼ é€’ä¿¡æ¯ã€‚åªæœ‰è£…äº†ã€æ²¡è¢«ç›‘è§†ã€è¢«ç›‘è§†ä¸‰ç§çŠ¶æ€ã€‚</p>

<h3 id="ä»£ç ">ä»£ç </h3>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int dfs(TreeNode* root,int &amp;res) {
        if (root == NULL) return 1;
        int s1 = dfs(root-&gt;left,res);
        int s2 = dfs(root-&gt;right,res);
        if (s1 == 3 || s2 == 3) {
            res++;
            return 2;
        }
        if (s1 == 2 || s2 == 2) {
            return 1;
        }
        return 3;
    }
    int minCameraCover(TreeNode* root) {
        int res = 0;
        if (dfs(root,res) == 3) 
            res++;
        return res;
    }
    
};
</code></pre>

<h3 id="æ”¶è·">æ”¶è·</h3>

<p>ååºéå†ï¼Œè¿˜æœ‰ä¸€äº›è´ªå¿ƒçš„æ€æƒ³</p>

:ET